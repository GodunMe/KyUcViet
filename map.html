<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>B·∫£n ƒë·ªì - Vietnamese Memories</title>
  <link rel="icon" type="image/png" href="logo.PNG" />
  <link rel="stylesheet" href="style.css" />
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Leaflet Routing Machine CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
  <!-- Leaflet Geocoder CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.css" />
  <style>
    /* Prevent body scroll on map page */
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }

    .container {
      height: 100%;
      overflow: hidden;
    }

    #mapContainer {
      height: calc(100vh - 60px);
      width: 100%;
      position: relative;
      overflow: hidden;
    }
    
    .map-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .control-btn {
      padding: 8px 12px;
      background: white;
      border: none;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s;
    }
    
    .control-btn:hover {
      background: #f0f0f0;
      transform: translateY(-1px);
    }
    
    .marker-popup {
      max-width: 250px;
    }
    
    .marker-popup h4 {
      margin: 0 0 8px 0;
      color: #333;
    }
    
    .marker-popup p {
      margin: 4px 0;
      font-size: 13px;
      color: #666;
    }

    /* Popup action buttons */
    .popup-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .popup-actions button {
      flex: 1 1 auto;
      padding: 6px 8px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
    }

    .popup-actions .details-btn {
      background: #007bff;
      color: white;
    }

    .popup-actions .route-btn {
      background: #28a745;
      color: white;
    }

    .popup-actions .lucky-btn {
      background: #ffc107;
      color: #333;
      font-weight: 500;
    }
    
    /* Lucky button style (outside .popup-actions too) */
    .lucky-btn {
      padding: 8px 12px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
      background: #ffc107;
      color: #333;
      font-weight: 500;
      width: 100%;
      margin: 8px 0;
    }
    
    .popup-actions .lucky-btn:disabled,
    .lucky-btn:disabled {
      background: #ccc;
      color: #666;
      cursor: not-allowed;
    }

    /* Coin icon animation - applied to inner element only, NOT the marker container */
    .coin-icon-inner {
      animation: coinPulse 2s infinite;
    }

    @keyframes coinPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* Photo upload modal */
    .photo-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 99999;
      justify-content: center;
      align-items: center;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .photo-modal.active {
      display: flex;
      visibility: visible;
      opacity: 1;
    }

    .photo-modal-content {
      background: white;
      padding: 20px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .photo-modal h3 {
      margin: 0 0 15px 0;
      color: #333;
    }

    .photo-preview {
      width: 100%;
      max-height: 300px;
      object-fit: cover;
      border-radius: 8px;
      margin: 10px 0;
      display: none;
    }

    .modal-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .modal-actions button {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    .modal-actions .submit-btn {
      background: #28a745;
      color: white;
    }

    .modal-actions .cancel-btn {
      background: #dc3545;
      color: white;
    }

    /* Ensure popup buttons receive pointer events (in case global CSS disables them) */
    .leaflet-popup-content button, .marker-popup button {
      pointer-events: auto;
    }

    /* Make sure popups sit above other UI elements */
    .leaflet-popup {
      z-index: 10000 !important;
    }

    /* Hide default Leaflet routing collapse button */
    .leaflet-routing-container-hide,
    .leaflet-routing-collapse-btn {
      display: none !important;
    }

    /* Custom close button for routing panel */
    .custom-close-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .custom-close-btn:hover {
      background: #cc0000;
      transform: scale(1.1);
    }

    .custom-close-btn:active {
      transform: scale(0.95);
    }

    /* Ensure routing container has relative positioning for absolute close button */
    .leaflet-routing-container {
      position: relative !important;
    }

    /* Coin History Modal */
    .coin-history-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 99999;
      justify-content: center;
      align-items: center;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .coin-history-modal.active {
      display: flex;
      visibility: visible;
      opacity: 1;
    }

    .coin-history-content {
      background: white;
      padding: 20px;
      border-radius: 12px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .coin-history-content h3 {
      margin: 0 0 15px 0;
      color: #333;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .history-item {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
      background: #f9f9f9;
    }

    .history-item.pending {
      border-left: 4px solid #ffc107;
    }

    .history-item.approved {
      border-left: 4px solid #28a745;
    }

    .history-item.rejected {
      border-left: 4px solid #dc3545;
    }

    .history-item h4 {
      margin: 0 0 8px 0;
      color: #333;
      font-size: 15px;
    }

    .history-item p {
      margin: 4px 0;
      font-size: 13px;
      color: #666;
    }

    .history-status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      margin-top: 8px;
    }

    .history-status.pending {
      background: #fff3cd;
      color: #856404;
    }

    .history-status.approved {
      background: #d4edda;
      color: #155724;
    }

    .history-status.rejected {
      background: #f8d7da;
      color: #721c24;
    }

    .close-history-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 15px;
      width: 100%;
    }
    
  </style>
</head>
<body>
  <div class="container">

    <!-- Map Container -->
    <div id="mapContainer">
      <!-- Map Controls -->
      <div class="map-controls">
        <button class="control-btn" onclick="locateUser()" title="T√¨m v·ªã tr√≠ c·ªßa t√¥i">
          üìç V·ªã tr√≠ c·ªßa t√¥i
        </button>
        <button id="routingToggleBtn" class="control-btn" onclick="toggleRoutingPanel()" title="·∫®n/hi·ªán h∆∞·ªõng d·∫´n">
          üìã H∆∞·ªõng d·∫´n
        </button>
        <button class="control-btn" onclick="openCoinHistory()" title="L·ªãch s·ª≠ nh·∫∑t xu">
          ü™ô L·ªãch s·ª≠ nh·∫∑t xu
        </button>
        <button id="cancelRouteBtn" class="control-btn" onclick="cancelRoute()" title="H·ªßy ch·ªâ ƒë∆∞·ªùng" style="display: none; background-color: #ff4444; color: white;">
          ‚ùå H·ªßy ch·ªâ ƒë∆∞·ªùng
        </button>
      </div>
    </div>

  </div>

  <!-- Bottom Navigation -->
  <div class="bottom-nav">
    <div class="nav-item" onclick="navigateToPage('home')">
      <div class="nav-icon">üè†</div>
      <div class="nav-label">Home</div>
    </div>
    <div class="nav-item active" onclick="navigateToPage('map')">
      <div class="nav-icon" style="position: relative;">
        üó∫Ô∏è
        <span id="coin-notification-dot" style="display: none; position: absolute; top: -2px; right: -2px; width: 8px; height: 8px; background: red; border-radius: 50%; border: 1px solid white;"></span>
      </div>
      <div class="nav-label">Map</div>
    </div>
    <div class="nav-item" onclick="navigateToPage('checkin')">
      <div class="nav-icon">üìç</div>
      <div class="nav-label">Check-in</div>
    </div>
    <div class="nav-item" onclick="navigateToPage('leaderboard')">
      <div class="nav-icon">üèÜ</div>
      <div class="nav-label">B·∫£ng x·∫øp h·∫°ng</div>
    </div>
    <div class="nav-item" onclick="navigateToPage('profile')">
      <div class="nav-icon">üë§</div>
      <div class="nav-label">Profile</div>
    </div>
  </div>

  <!-- Photo Upload Modal -->
  <div id="photoModal" class="photo-modal">
    <div class="photo-modal-content">
      <h3>üì∏ Ch·ª•p ·∫£nh b·∫±ng ch·ª©ng</h3>
      <p style="font-size: 13px; color: #666; margin: 10px 0;">
        Ch·ª•p ·∫£nh t·∫°i b·∫£o t√†ng ƒë·ªÉ x√°c nh·∫≠n b·∫°n ƒëang ·ªü ƒë√¢y
      </p>
      
      <input type="file" id="photoInput" accept="image/*" capture="environment" 
             style="display: block; margin: 10px 0; width: 100%;">
      
      <img id="photoPreview" class="photo-preview" alt="Preview">
      
      <div class="modal-actions">
        <button class="cancel-btn" onclick="closePhotoModal()">H·ªßy</button>
        <button class="submit-btn" id="submitPhotoBtn" onclick="submitCoinPickup()">G·ª≠i</button>
      </div>
    </div>
  </div>

  <!-- Coin History Modal -->
  <div id="coinHistoryModal" class="coin-history-modal">
    <div class="coin-history-content">
      <h3>ü™ô L·ªãch s·ª≠ nh·∫∑t xu may m·∫Øn</h3>
      <div id="historyList">
        <p style="text-align: center; color: #666;">ƒêang t·∫£i...</p>
      </div>
      <button class="close-history-btn" onclick="closeCoinHistory()">ƒê√≥ng</button>
    </div>
  </div>
      
      <img id="photoPreview" class="photo-preview" alt="Preview">
      
      <div class="modal-actions">
        <button class="cancel-btn" onclick="closePhotoModal()">H·ªßy</button>
        <button class="submit-btn" id="submitPhotoBtn" onclick="submitCoinPickup()">G·ª≠i</button>
      </div>
    </div>
  </div>


  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Leaflet Routing Machine JS -->
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
  <!-- Leaflet Geocoder JS -->
  <script src="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.js"></script>
  
  <script>
    let map;
    let userMarker;
    let markers = [];
    let currentUserLocation = null;
    let routingControl = null;
    let destinationMarker = null;

    // Museum data - loaded from database
    let museumMarkers = [];

    // Load user info on page load
    // Helper to safely parse JSON responses (avoids Uncaught SyntaxError on empty responses)
    async function safeFetchJson(response) {
      try {
        const text = await response.text();
        if (!text) return null;
        const trimmed = text.trim();
        // If response looks like HTML (starts with <), don't try to parse as JSON
        if (trimmed.startsWith('<')) {
          return null;
        }
        return JSON.parse(text);
      } catch (err) {
        console.warn('safeFetchJson: failed to parse JSON', err);
        return null;
      }
    }

    async function loadUserInfo() {
      try {
        const response = await fetch('profile/getUserInfo.php');
        if (response.ok) {
          const data = await safeFetchJson(response);
          
          if (data && data.loggedIn) {
            showUserLoggedInState(data);
          } else {
            showUserNotLoggedInState();
          }
        } else {
          showUserNotLoggedInState();
        }
      } catch (error) {
        console.error('Error loading user info:', error);
        showUserNotLoggedInState();
      }
    }

    function showUserLoggedInState(userData) {
      // Defensive: only modify DOM if the expected elements exist on this page
      try {
        const loggedInDiv = document.getElementById('userLoggedIn');
        const notLoggedInDiv = document.getElementById('usernotLoggedIn');
        if (loggedInDiv && notLoggedInDiv) {
          // Show logged in state, hide not logged in state
          loggedInDiv.style.display = 'flex';
          notLoggedInDiv.style.display = 'none';

          // Update user avatar
          const avatarElement = document.getElementById('userAvatar');
          if (avatarElement) avatarElement.src = userData.avatarRelative || 'avatar/default.png';

          // Update user name
          const nameElement = document.getElementById('userName');
          if (nameElement) nameElement.textContent = userData.username || 'Guest User';

          // Apply role-based styling
          if (nameElement) nameElement.classList.remove('admin', 'customerpre', 'customer');
          if (avatarElement) avatarElement.classList.remove('admin', 'customerpre', 'customer');
          const role = userData.role ? userData.role.toLowerCase() : 'customer';
          if (nameElement) nameElement.classList.add(role);
          if (avatarElement) avatarElement.classList.add(role);

          // Update user points
          const pointsElement = document.getElementById('userPoints');
          if (pointsElement) pointsElement.textContent = (userData.score || 0);
        } else {
          // Page does not have user header area ‚Äî skip DOM updates
          
        }
      } catch (err) {
        console.error('showUserLoggedInState error:', err);
      }
    }

    function showUserNotLoggedInState() {
      try {
        const loggedInDiv = document.getElementById('userLoggedIn');
        const notLoggedInDiv = document.getElementById('usernotLoggedIn');
        if (loggedInDiv && notLoggedInDiv) {
          // Show not logged in state, hide logged in state
          loggedInDiv.style.display = 'none';
          notLoggedInDiv.style.display = 'flex';
        } else {
          
        }
      } catch (err) {
        console.error('showUserNotLoggedInState error:', err);
      }
    }

    function goToLogin() {
      // Redirect to login page
      window.location.href = 'login.php?token=1';
    }

    function navigateToPage(page) {
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
      });
      
      event.target.closest('.nav-item').classList.add('active');
      
      switch(page) {
        case 'home':
          window.location.href = '/index.php';
          break;
        case 'map':
          // Already on map page
          break;
        case 'checkin':
          window.location.href = '/checkin/checkin.html';
          break;
        case 'leaderboard':
          window.location.href = '/leaderboard/leaderboard.html';
          break;
        case 'profile':
          window.location.href = '/profile/profile.html';
          break;
      }
    }

    // Map functions
    function initMap() {
      // Initialize map with default location (Hanoi)
      map = L.map('mapContainer').setView([21.0285, 105.8542], 13);

      // Add OpenStreetMap tiles
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors'
      }).addTo(map);

      // Get user location and center map
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          position => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            currentUserLocation = [lat, lng];
            
            // Center map on user location
            map.setView([lat, lng], 15);
            
            // Add user marker
            if (userMarker) {
              map.removeLayer(userMarker);
            }
            
            userMarker = L.marker([lat, lng], {
              icon: L.divIcon({
                className: 'user-marker',
                html: '<div style="background: #007bff; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">üìç</div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
              })
            }).addTo(map);
            
            userMarker.bindPopup('<b>V·ªã tr√≠ c·ªßa b·∫°n</b>').openPopup();
            
            // Update address
            reverseGeocode(lat, lng).then(address => {
              if (address) {
                userMarker.setPopupContent(`<b>V·ªã tr√≠ c·ªßa b·∫°n</b><br>${address}`);
              }
            });
          },
          error => {
            console.warn('Geolocation error:', error);
            alert('Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i. S·ª≠ d·ª•ng v·ªã tr√≠ m·∫∑c ƒë·ªãnh.');
          }
        );
      }

      // Load lucky coins first, then load markers (so icons are correct from the start)
      loadLuckyCoins().then(() => {
        loadMarkers();
      });

      // Attach popupopen handler here after map is initialized
      if (map && map.on) {
        map.on('popupopen', function(e) {
          try {
            const popupEl = e.popup.getElement();
            if (!popupEl) return;
            const container = popupEl.querySelector('.marker-popup');
            if (!container) return;

            const museumId = container.getAttribute('data-museum-id');
            const museumName = container.getAttribute('data-museum-name');
            const lat = container.getAttribute('data-lat');
            const lng = container.getAttribute('data-lng');

            const detailsBtn = container.querySelector('.details-btn');
            const routeBtn = container.querySelector('.route-btn');
            const luckyBtn = container.querySelector('.lucky-btn');

            if (detailsBtn) {
              detailsBtn.onclick = function(evt) { viewMuseumDetails(evt, museumId); };
            }
            if (routeBtn) {
              routeBtn.onclick = function(evt) { getDirections(evt, museumId, museumName, lat, lng); };
            }
            if (luckyBtn) {
              luckyBtn.onclick = function(evt) { pickLuckyCoin(museumId); };
            }
          } catch (err) {
            console.error('popupopen handler error', err);
          }
        });
      }
    }

    async function loadMarkers() {
      // Clear existing markers
      markers.forEach(marker => map.removeLayer(marker.leafletMarker));
      markers = [];

      try {
        // Fetch museums from database using existing API
        const response = await fetch('getMuseums.php');
        if (!response.ok) {
          throw new Error('Failed to fetch museums');
        }
        
        const museums = await safeFetchJson(response) || [];
        
        // Convert getMuseums.php format to map format
        museumMarkers = museums.map(museum => ({
          id: museum.MuseumID,
          name: museum.MuseumName,
          lat: parseFloat(museum.Latitude),
          lng: parseFloat(museum.Longitude),
          type: 'museum',
          description: museum.Description || 'B·∫£o t√†ng vƒÉn h√≥a l·ªãch s·ª≠',
          address: museum.Address || 'ƒêang c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ...'
        }));
        
        // Add markers to map
        museumMarkers.forEach(markerData => {
          addMarkerToMap(markerData);
        });
        
      } catch (error) {
        console.error('Error loading markers:', error);
        alert('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu b·∫£o t√†ng. Vui l√≤ng th·ª≠ l·∫°i sau.');
      }
    }

    function addMarkerToMap(markerData) {
      // Check if this museum has an active coin
      const coinData = activeCoins.find(c => String(c.museum_id) === String(markerData.id));
      const hasCoin = coinData !== undefined;
      const alreadyPicked = hasCoin && coinData.already_picked === true;
      
      // Show coin icon ONLY if coin exists AND user hasn't picked it yet
      const showCoinIcon = hasCoin && !alreadyPicked;
      
      // Use coin icon if museum has unpicked coin, otherwise use regular museum icon
      const iconHtml = showCoinIcon ? getCoinMarkerIcon() : getMarkerIcon(markerData.type);
      
      const marker = L.marker([markerData.lat, markerData.lng], {
        icon: L.divIcon({
          className: showCoinIcon ? 'custom-marker coin-marker' : 'custom-marker',
          html: iconHtml,
          iconSize: [32, 32],
          iconAnchor: [16, 16],  // Center point - same for both icons
          popupAnchor: [0, -16]  // Same popup position for both
        })
      }).addTo(map);

      // Truncate description for popup to keep it concise
      function truncateText(text, maxChars = 120) {
        if (!text) return '';
        const cleaned = String(text).trim();
        if (cleaned.length <= maxChars) return cleaned;
        // Try to cut at a word boundary
        const truncated = cleaned.slice(0, maxChars);
        return truncated.replace(/\s+\S*$/, '') + '...';
      }

      const shortDesc = markerData.description ? truncateText(markerData.description, 140) : 'Kh√¥ng c√≥ m√¥ t·∫£';

      // Build popup content with conditional coin button
      let coinButton = '';
      if (hasCoin) {
        if (alreadyPicked) {
          // Already picked - show info message
          coinButton = '<p style="color: #28a745; font-weight: 500; margin: 8px 0;">‚úÖ ƒê√£ nh·∫∑t xu n√†y</p>';
        } else {
          // Not picked yet - show pickup button
          coinButton = '<button class="lucky-btn">ü™ô Nh·∫∑t xu may m·∫Øn</button>';
        }
      }

      const popupContent = `
        <div class="marker-popup" data-museum-id="${markerData.id}" data-museum-name="${escapeHtml(markerData.name)}" data-lat="${markerData.lat}" data-lng="${markerData.lng}">
          <h4>${showCoinIcon ? 'ü™ô ' : ''}${escapeHtml(markerData.name)}</h4>
          <p><strong>Lo·∫°i:</strong> ${getTypeLabel(markerData.type)}</p>
          <p><strong>M√¥ t·∫£:</strong> ${escapeHtml(shortDesc)}</p>
          <p><strong>ƒê·ªãa ch·ªâ:</strong> ${escapeHtml(markerData.address || 'ƒêang c·∫≠p nh·∫≠t...')}</p>
          ${coinButton}
          <div class="popup-actions">
            <button class="details-btn">Xem chi ti·∫øt</button>
            <button class="route-btn">Ch·ªâ ƒë∆∞·ªùng</button>
          </div>
        </div>
      `;

      marker.bindPopup(popupContent);

      // Store marker data
      markers.push({
        id: markerData.id,
        data: markerData,
        leafletMarker: marker
      });
    }

    function getMarkerIcon(type) {
      const icons = {
        museum: 'üèõÔ∏è',
        historical: 'üèõÔ∏è',
        cultural: 'üé≠',
        tourist: 'üìç',
        other: 'üìå'
      };
      
      const icon = icons[type] || 'üìå';
      return `<div style="background: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 2px solid #333; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${icon}</div>`;
    }

    function getCoinMarkerIcon() {
      return `<div class="coin-icon-inner" style="background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%); border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 3px solid #ff8c00; box-shadow: 0 0 10px rgba(255, 215, 0, 0.8), 0 2px 6px rgba(0,0,0,0.4);">ü™ô</div>`;
    }

    function getTypeLabel(type) {
      const labels = {
        museum: 'B·∫£o t√†ng',
        historical: 'Di t√≠ch l·ªãch s·ª≠',
        cultural: 'VƒÉn h√≥a',
        tourist: 'Du l·ªãch',
        other: 'Kh√°c'
      };
      return labels[type] || 'Kh√°c';
    }

    // Escape text before inserting into inline HTML to avoid breaking attributes
    function escapeHtml(str) {
      if (str === undefined || str === null) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    // Helper: open museum detail page (with login check, same behavior as index.php)
    function viewMuseumDetails(e, museumId) {
      try {
        
        // Accept either (museumId) or (event, museumId)
        if (museumId === undefined && e !== undefined && typeof e === 'number') {
          museumId = e; e = null;
        }
        if (e && e.stopPropagation) e.stopPropagation();
        if (!museumId) {
          alert('L·ªói: kh√¥ng t√¨m th·∫•y ID b·∫£o t√†ng.');
          return;
        }

        // Check login status first (same flow as index.php -> viewMuseumDetails)
        fetch('profile/getUserInfo.php')
          .then(async response => await safeFetchJson(response))
          .then(data => {
            if (data && data.loggedIn) {
              // User is logged in - allow access to museum details
              window.location.href = `/museum.html?id=${museumId}&fromMap=true`;
            } else {
              // Not logged in - notify and send to NFC/login required page
              alert('B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ xem chi ti·∫øt b·∫£o t√†ng!');
              window.location.href = '/nfc_required.html';
            }
          })
          .catch(error => {
            console.error('Error checking login status:', error);
            alert('B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ xem chi ti·∫øt b·∫£o t√†ng!');
            window.location.href = '/nfc_required.html';
          });
      } catch (err) {
        console.error('viewMuseumDetails error', err);
        alert('L·ªói n·ªôi b·ªô khi m·ªü chi ti·∫øt. Ki·ªÉm tra console.');
      }
    }

    // Helper: trigger route to a destination (uses existing handler if available)
    function openRouteTo(lat, lng, name) {
      if (!lat || !lng) return alert('Kh√¥ng c√≥ t·ªça ƒë·ªô h·ª£p l·ªá ƒë·ªÉ ch·ªâ ƒë∆∞·ªùng.');

      const doRoute = () => {
        if (typeof handleDirectionsRequest === 'function') {
          handleDirectionsRequest({ route: true, lat: String(lat), lng: String(lng), name: name || '' });
          return;
        }

        // Fallback: center map and show a destination marker
        const destination = [parseFloat(lat), parseFloat(lng)];
        if (destinationMarker) {
          map.removeLayer(destinationMarker);
          destinationMarker = null;
        }
        destinationMarker = L.marker(destination).addTo(map).bindPopup(`<b>${name || 'ƒê√≠ch ƒë·∫øn'}</b>`).openPopup();
        map.setView(destination, 15);
      };

      // If we already have user location, proceed. Otherwise try to obtain it first.
      if (currentUserLocation && Array.isArray(currentUserLocation) && currentUserLocation.length === 2) {
        doRoute();
      } else if (navigator.geolocation) {
        // Ask for geolocation then route
        navigator.geolocation.getCurrentPosition(
          pos => {
            currentUserLocation = [pos.coords.latitude, pos.coords.longitude];
            // Update or create user marker
            if (userMarker) {
              userMarker.setLatLng(currentUserLocation);
            } else {
              userMarker = L.marker(currentUserLocation, {
                icon: L.divIcon({
                  className: 'user-marker',
                  html: '<div style="background: #007bff; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">üìç</div>',
                  iconSize: [20,20],
                  iconAnchor: [10,10]
                })
              }).addTo(map);
            }
            doRoute();
          },
          err => {
            console.warn('Geolocation unavailable:', err);
            alert('Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i ‚Äî kh√¥ng th·ªÉ t·∫°o ch·ªâ ƒë∆∞·ªùng.');
          },
          { enableHighAccuracy: true, timeout: 8000 }
        );
      } else {
        alert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ Geolocation.');
      }
    }

    // Placeholder for the "lucky coin" action
    let currentCoinId = null; // Store current coin being picked up
    let activeCoins = []; // Store active coins data

    async function pickLuckyCoin(museumId) {
      try {
        // Check if user is logged in first
        const userResponse = await fetch('/getUserInfo.php');
        const userData = await userResponse.json();
        
        if (!userData.loggedIn) {
          alert('B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ nh·∫∑t xu may m·∫Øn!');
          window.location.href = '/login.php';
          return;
        }
        
        // Fetch latest coin data to ensure accuracy
        const response = await fetch('/lucky_coin/getLuckyCoins.php');
        const data = await response.json();
        
        if (!data.success) {
          alert('Kh√¥ng th·ªÉ t·∫£i th√¥ng tin xu may m·∫Øn!');
          return;
        }
        
        // Update activeCoins cache
        activeCoins = data.coins;
        
        // Find coin for this museum (convert both to string for comparison)
        const coin = activeCoins.find(c => String(c.museum_id) === String(museumId));
        
        if (!coin) {
          alert('Xu may m·∫Øn ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng t·ªìn t·∫°i!');
          return;
        }
        
        // Check if already picked
        if (coin.already_picked) {
          alert('B·∫°n ƒë√£ nh·∫∑t xu n√†y r·ªìi!');
          return;
        }
        
        // Store coin ID for submission
        currentCoinId = coin.coin_id;
        
        // Open photo modal
        const modal = document.getElementById('photoModal');
        modal.classList.add('active');
      } catch (error) {
        console.error('Error loading coin:', error);
        alert('L·ªói khi t·∫£i th√¥ng tin xu may m·∫Øn!');
      }
    }

    function closePhotoModal() {
      const modal = document.getElementById('photoModal');
      modal.classList.remove('active');
      document.getElementById('photoInput').value = '';
      document.getElementById('photoPreview').style.display = 'none';
      currentCoinId = null;
    }

    async function submitCoinPickup() {
      const photoInput = document.getElementById('photoInput');
      
      if (!photoInput.files || !photoInput.files[0]) {
        alert('Vui l√≤ng ch·ªçn ·∫£nh!');
        return;
      }
      
      if (!currentCoinId) {
        alert('L·ªói: Kh√¥ng t√¨m th·∫•y coin ID');
        closePhotoModal();
        return;
      }
      
      // Disable submit button
      const submitBtn = document.getElementById('submitPhotoBtn');
      submitBtn.disabled = true;
      submitBtn.textContent = 'ƒêang l·∫•y v·ªã tr√≠...';
      
      // Get user's current GPS location
      if (!navigator.geolocation) {
        alert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ GPS!');
        submitBtn.disabled = false;
        submitBtn.textContent = 'G·ª≠i';
        return;
      }
      
      navigator.geolocation.getCurrentPosition(
        async (position) => {
          const userLat = position.coords.latitude;
          const userLng = position.coords.longitude;
          
          submitBtn.textContent = 'ƒêang g·ª≠i...';
          
          try {
            const formData = new FormData();
            formData.append('coin_id', currentCoinId);
            formData.append('photo', photoInput.files[0]);
            formData.append('user_lat', userLat);
            formData.append('user_lng', userLng);
            
            const response = await fetch('/lucky_coin/pickupCoin.php', {
              method: 'POST',
              body: formData
            });
            
            const data = await response.json();
            
            if (data.success) {
              alert(`‚úÖ ${data.message}\n\nB·∫£o t√†ng: ${data.museum_name}\nƒêi·ªÉm ch·ªù duy·ªát: +${data.points_pending}${data.distance ? `\nKho·∫£ng c√°ch: ${data.distance}m` : ''}`);
              closePhotoModal();
              
              // Reload coins to update UI
              loadLuckyCoins();
            } else {
              alert(`‚ùå L·ªói: ${data.message}`);
            }
          } catch (error) {
            console.error('Pickup error:', error);
            alert('L·ªói k·∫øt n·ªëi! Vui l√≤ng th·ª≠ l·∫°i.');
          } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = 'G·ª≠i';
          }
        },
        (error) => {
          console.error('Geolocation error:', error);
          let errorMsg = 'Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ GPS!';
          
          switch(error.code) {
            case error.PERMISSION_DENIED:
              errorMsg = 'B·∫°n ƒë√£ t·ª´ ch·ªëi quy·ªÅn truy c·∫≠p v·ªã tr√≠. Vui l√≤ng b·∫≠t GPS v√† cho ph√©p truy c·∫≠p!';
              break;
            case error.POSITION_UNAVAILABLE:
              errorMsg = 'Kh√¥ng th·ªÉ x√°c ƒë·ªãnh v·ªã tr√≠. Vui l√≤ng ki·ªÉm tra GPS!';
              break;
            case error.TIMEOUT:
              errorMsg = 'Qu√° th·ªùi gian l·∫•y v·ªã tr√≠. Vui l√≤ng th·ª≠ l·∫°i!';
              break;
          }
          
          alert(errorMsg);
          submitBtn.disabled = false;
          submitBtn.textContent = 'G·ª≠i';
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 0
        }
      );
    }

    // Photo preview
    document.addEventListener('DOMContentLoaded', function() {
      const photoInput = document.getElementById('photoInput');
      const photoPreview = document.getElementById('photoPreview');
      
      if (photoInput) {
        photoInput.addEventListener('change', function(e) {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
              photoPreview.src = e.target.result;
              photoPreview.style.display = 'block';
            };
            reader.readAsDataURL(file);
          }
        });
      }
    });

    // =====================================================
    // Coin History Modal Functions
    // =====================================================
    
    async function openCoinHistory() {
      try {
        // Check if user is logged in
        const userResponse = await fetch('/getUserInfo.php');
        const userData = await userResponse.json();
        
        if (!userData.loggedIn) {
          alert('B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ xem l·ªãch s·ª≠ nh·∫∑t xu!');
          window.location.href = '/login.php';
          return;
        }
        
        // Show modal
        const modal = document.getElementById('coinHistoryModal');
        modal.classList.add('active');
        
        // Load history
        const response = await fetch('/lucky_coin/getCoinHistory.php');
        const data = await response.json();
        
        const historyList = document.getElementById('historyList');
        
        if (!data.success) {
          historyList.innerHTML = `<p style="text-align: center; color: #dc3545;">‚ùå ${data.message || 'Kh√¥ng th·ªÉ t·∫£i l·ªãch s·ª≠'}</p>`;
          return;
        }
        
        if (data.count === 0) {
          historyList.innerHTML = `
            <p style="text-align: center; color: #666; padding: 20px;">
              B·∫°n ch∆∞a nh·∫∑t xu may m·∫Øn n√†o.<br>
              H√£y t√¨m ƒë·ªìng xu ü™ô tr√™n b·∫£n ƒë·ªì v√† nh·∫∑t ngay!
            </p>
          `;
          return;
        }
        
        // Render history items
        let html = '';
        data.history.forEach(item => {
          html += `
            <div class="history-item ${item.status}">
              <h4>üèõÔ∏è ${escapeHtml(item.museum_name)}</h4>
              <p><strong>üìç ƒê·ªãa ch·ªâ:</strong> ${escapeHtml(item.museum_address || 'ƒêang c·∫≠p nh·∫≠t')}</p>
              <p><strong>‚è∞ Th·ªùi gian nh·∫∑t:</strong> ${item.pickup_time}</p>
              <p><strong>ÔøΩ ƒêi·ªÉm:</strong> ${item.status === 'approved' ? `+${item.points_awarded}` : `Ch·ªù duy·ªát (+${item.points_awarded})`}</p>
              <span class="history-status ${item.status}">${item.status_label}</span>
              ${item.reject_reason ? `<p style="margin-top: 8px; padding: 8px; background: #fff; border-radius: 4px;"><strong>üìù L√Ω do t·ª´ ch·ªëi:</strong> ${escapeHtml(item.reject_reason)}</p>` : ''}
            </div>
          `;
        });
        
        historyList.innerHTML = html;
        
      } catch (error) {
        console.error('Error loading coin history:', error);
        alert('L·ªói khi t·∫£i l·ªãch s·ª≠ nh·∫∑t xu!');
      }
    }
    
    function closeCoinHistory() {
      const modal = document.getElementById('coinHistoryModal');
      modal.classList.remove('active');
    }

    // =====================================================
    // Lucky Coins Functions
    // =====================================================

    // Load lucky coins from API
    async function loadLuckyCoins() {
      try {
        const response = await fetch('/lucky_coin/getLuckyCoins.php');
        const data = await response.json();
        
        if (data.success) {
          const previousCount = activeCoins.length;
          activeCoins = data.coins;
          
          // Note: Red dot is handled by global lucky_coin_notification.js
          // This function just updates activeCoins for popup display
          
          // Only reload markers if coin count changed AND this is not the initial load
          // (Initial load: previousCount === 0, markers will be loaded by initMap's .then())
          if (previousCount > 0 && activeCoins.length !== previousCount) {
            loadMarkers(); // Refresh all markers to update popups
          }
          
          return activeCoins; // RETURN the coins array
        } else {
          return []; // Return empty array if failed
        }
      } catch (error) {
        console.error('Failed to load lucky coins:', error);
        return []; // Return empty array on error
      }
    }

    // Poll for lucky coins every 60 seconds (for map-specific coin data)
    let coinPollInterval;
    function startCoinPolling() {
      loadLuckyCoins(); // Initial load
      coinPollInterval = setInterval(loadLuckyCoins, 60000); // Every 60 seconds
    }

    function stopCoinPolling() {
      if (coinPollInterval) {
        clearInterval(coinPollInterval);
      }
    }

    // Start polling when page visibility changes
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        stopCoinPolling();
      } else {
        startCoinPolling();
      }
    });


    // getDirections: signature similar to index.php for consistency
    function getDirections(e, museumId, museumName, lat, lng) {
      try {
        
        if (e && e.stopPropagation) e.stopPropagation();
        // Use the existing openRouteTo helper which will obtain geolocation and call handleDirectionsRequest
        openRouteTo(lat, lng, museumName);
      } catch (err) {
        console.error('getDirections error', err);
        alert('L·ªói khi b·∫Øt ƒë·∫ßu ch·ªâ ƒë∆∞·ªùng. Ki·ªÉm tra console.');
      }
    }


    function locateUser() {
      if (currentUserLocation) {
        map.setView(currentUserLocation, 16);
        if (userMarker) {
          userMarker.openPopup();
        }
      } else {
        alert('V·ªã tr√≠ ch∆∞a ƒë∆∞·ª£c x√°c ƒë·ªãnh');
      }
    }

    // Cancel route and clear directions
    function cancelRoute() {
      // Remove routing control if exists
      if (routingControl) {
        map.removeControl(routingControl);
        routingControl = null;
      }
      
      // Remove destination marker if exists
      if (destinationMarker) {
        map.removeLayer(destinationMarker);
        destinationMarker = null;
      }
      
      // Hide cancel route button and reset routing toggle button
      document.getElementById('cancelRouteBtn').style.display = 'none';
      document.getElementById('routingToggleBtn').innerHTML = 'üìã H∆∞·ªõng d·∫´n';
      document.getElementById('routingToggleBtn').title = '·∫®n/hi·ªán h∆∞·ªõng d·∫´n';
      
      // Optionally return to user location
      if (currentUserLocation) {
        map.setView(currentUserLocation, 14);
      }
    }

    // Toggle routing panel visibility
    function toggleRoutingPanel() {
      if (routingControl) {
        const routingContainer = document.querySelector('.leaflet-routing-container');
        if (routingContainer) {
          const isHidden = routingContainer.style.display === 'none';
          routingContainer.style.display = isHidden ? 'block' : 'none';
          
          // Update button text
          const toggleBtn = document.getElementById('routingToggleBtn');
          if (isHidden) {
            toggleBtn.innerHTML = 'üìã H∆∞·ªõng d·∫´n';
            toggleBtn.title = '·∫®n h∆∞·ªõng d·∫´n';
          } else {
            toggleBtn.innerHTML = 'üìã Hi·ªán h∆∞·ªõng d·∫´n';
            toggleBtn.title = 'Hi·ªán h∆∞·ªõng d·∫´n';
          }
        }
      } else {
        // No routing active - show message
        alert('Ch∆∞a c√≥ ch·ªâ ƒë∆∞·ªùng n√†o ƒë∆∞·ª£c t·∫°o. H√£y ch·ªçn "Ch·ªâ ƒë∆∞·ªùng" t·ª´ m·ªôt b·∫£o t√†ng ƒë·ªÉ b·∫Øt ƒë·∫ßu.');
      }
    }

    async function reverseGeocode(lat, lng) {
      try {
        // Use local proxy to avoid CORS issues (proxy.php forwards request to Nominatim)
        const response = await fetch(`proxy.php?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}`);
        const data = await safeFetchJson(response);
        return (data && data.display_name) ? data.display_name : '';
      } catch (error) {
        console.error('Reverse geocoding error:', error);
        return '';
      }
    }

    function toggleMarkerList() {
      // Create a list of all markers
      let listHtml = '<h4>Danh s√°ch ƒëi·ªÉm ƒë√°nh d·∫•u:</h4>';
      markers.forEach(marker => {
        listHtml += `
          <div style="margin: 8px 0; padding: 8px; background: #f9f9f9; border-radius: 4px; cursor: pointer;" onclick="map.setView([${marker.data.lat}, ${marker.data.lng}], 16); markers.find(m => m.id === ${marker.id}).leafletMarker.openPopup();">
            <strong>${marker.data.name}</strong><br>
            <small>${getTypeLabel(marker.data.type)}</small>
          </div>
        `;
      });
      
      // Show in a popup
      const popup = L.popup()
        .setLatLng(map.getCenter())
        .setContent(listHtml)
        .openOn(map);
    }


    // Parse URL parameters
    function getUrlParams() {
      const params = new URLSearchParams(window.location.search);
      return {
        highlight: params.get('highlight'),
        name: params.get('name'),
        lat: params.get('lat'),
        lng: params.get('lng'),
        route: params.get('route') === 'true'
      };
    }

    // Handle directions from index.php
    function handleDirectionsRequest(params) {
      if (params.route && params.lat && params.lng && currentUserLocation) {
        const destination = [parseFloat(params.lat), parseFloat(params.lng)];
        
        // Clear existing route if any
        cancelRoute();
        
        // Highlight destination marker
        destinationMarker = L.marker(destination, {
          icon: L.divIcon({
            className: 'highlight-marker',
            html: '<div style="background: #ff4444; color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 24px; border: 3px solid white; box-shadow: 0 3px 6px rgba(0,0,0,0.4);">üèõÔ∏è</div>',
            iconSize: [40, 40],
            iconAnchor: [20, 40]
          })
        }).addTo(map);

        destinationMarker.bindPopup(`<b>${params.name}</b><br>ƒê√≠ch ƒë·∫øn c·ªßa b·∫°n`).openPopup();

        // Try to create route if routing library is available
        if (typeof L.Routing !== 'undefined') {
          try {
            routingControl = L.Routing.control({
              waypoints: [
                L.latLng(currentUserLocation[0], currentUserLocation[1]),
                L.latLng(destination[0], destination[1])
              ],
              routeWhileDragging: false,
              addWaypoints: false,
              createMarker: function() { return null; }, // Hide default markers
              lineOptions: {
                styles: [{ color: '#007bff', weight: 6, opacity: 0.8 }]
              }
            }).addTo(map);
            
            // Hide routing panel by default and add close button
            setTimeout(() => {
              const routingContainer = document.querySelector('.leaflet-routing-container');
              if (routingContainer) {
                routingContainer.style.display = 'none';
                
                // Add custom close button if not already exists
                if (!routingContainer.querySelector('.custom-close-btn')) {
                  const closeBtn = document.createElement('button');
                  closeBtn.className = 'custom-close-btn';
                  closeBtn.innerHTML = '‚úï';
                  closeBtn.title = 'ƒê√≥ng h∆∞·ªõng d·∫´n';
                  closeBtn.onclick = function() {
                    routingContainer.style.display = 'none';
                    // Update toggle button text
                    document.getElementById('routingToggleBtn').innerHTML = 'üìã Hi·ªán h∆∞·ªõng d·∫´n';
                    document.getElementById('routingToggleBtn').title = 'Hi·ªán h∆∞·ªõng d·∫´n';
                  };
                  
                  // Insert close button at the top of routing container
                  routingContainer.insertBefore(closeBtn, routingContainer.firstChild);
                }
              }
            }, 100);
            
            // Show cancel route button and update routing toggle button
            document.getElementById('cancelRouteBtn').style.display = 'block';
            document.getElementById('routingToggleBtn').innerHTML = 'üìã Hi·ªán h∆∞·ªõng d·∫´n';
            document.getElementById('routingToggleBtn').title = 'Hi·ªán h∆∞·ªõng d·∫´n';
          } catch (error) {
            console.warn('Routing not available:', error);
          }
        }
        
        // Center map to show route
        setTimeout(() => {
          map.fitBounds([currentUserLocation, destination], { padding: [20, 20] });
        }, 1000);
      }
    }

    // Initialize map when page loads
    document.addEventListener('DOMContentLoaded', function() {
      loadUserInfo();
      initMap();
      
      // Start lucky coin polling
      startCoinPolling();
      
      // Handle URL parameters after map is initialized
      setTimeout(() => {
        const params = getUrlParams();
        if (params.highlight || params.route) {
          handleDirectionsRequest(params);
        }
      }, 2000); // Wait for geolocation to complete
    });
    
  </script>

  <!-- Lucky Coin Notification (shared script for all pages) -->
  <script src="/lucky_coin/lucky_coin_notification.js"></script>
</body>
</html>