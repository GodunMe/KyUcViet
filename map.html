<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>B·∫£n ƒë·ªì - Vietnamese Memories</title>
  <link rel="icon" type="image/png" href="logo.PNG" />
  <link rel="stylesheet" href="style.css" />
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Leaflet Routing Machine CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
  <!-- Leaflet Geocoder CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.css" />
  <style>
    #mapContainer {
      height: calc(100vh - 60px);
      width: 100%;
      position: relative;
    }
    
    .map-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .control-btn {
      padding: 8px 12px;
      background: white;
      border: none;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s;
    }
    
    .control-btn:hover {
      background: #f0f0f0;
      transform: translateY(-1px);
    }
    
    .marker-popup {
      max-width: 250px;
    }
    
    .marker-popup h4 {
      margin: 0 0 8px 0;
      color: #333;
    }
    
    .marker-popup p {
      margin: 4px 0;
      font-size: 13px;
      color: #666;
    }

    /* Hide default Leaflet routing collapse button */
    .leaflet-routing-container-hide,
    .leaflet-routing-collapse-btn {
      display: none !important;
    }

    /* Custom close button for routing panel */
    .custom-close-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .custom-close-btn:hover {
      background: #cc0000;
      transform: scale(1.1);
    }

    .custom-close-btn:active {
      transform: scale(0.95);
    }

    /* Ensure routing container has relative positioning for absolute close button */
    .leaflet-routing-container {
      position: relative !important;
    }
    
  </style>
</head>
<body>
  <div class="container">

    <!-- Map Container -->
    <div id="mapContainer">
      <!-- Map Controls -->
      <div class="map-controls">
        <button class="control-btn" onclick="locateUser()" title="T√¨m v·ªã tr√≠ c·ªßa t√¥i">
          üìç V·ªã tr√≠ c·ªßa t√¥i
        </button>
        <button id="routingToggleBtn" class="control-btn" onclick="toggleRoutingPanel()" title="·∫®n/hi·ªán h∆∞·ªõng d·∫´n">
          üìã H∆∞·ªõng d·∫´n
        </button>
        <button id="cancelRouteBtn" class="control-btn" onclick="cancelRoute()" title="H·ªßy ch·ªâ ƒë∆∞·ªùng" style="display: none; background-color: #ff4444; color: white;">
          ‚ùå H·ªßy ch·ªâ ƒë∆∞·ªùng
        </button>
      </div>
    </div>

  </div>

  <!-- Bottom Navigation -->
  <div class="bottom-nav">
    <div class="nav-item" onclick="navigateToPage('home')">
      <div class="nav-icon">üè†</div>
      <div class="nav-label">Home</div>
    </div>
    <div class="nav-item active" onclick="navigateToPage('map')">
      <div class="nav-icon">üó∫Ô∏è</div>
      <div class="nav-label">Map</div>
    </div>
    <div class="nav-item" onclick="navigateToPage('checkin')">
      <div class="nav-icon">üìç</div>
      <div class="nav-label">Check-in</div>
    </div>
    <div class="nav-item" onclick="navigateToPage('leaderboard')">
      <div class="nav-icon">üèÜ</div>
      <div class="nav-label">B·∫£ng x·∫øp h·∫°ng</div>
    </div>
    <div class="nav-item" onclick="navigateToPage('profile')">
      <div class="nav-icon">üë§</div>
      <div class="nav-label">Profile</div>
    </div>
  </div>


  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Leaflet Routing Machine JS -->
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
  <!-- Leaflet Geocoder JS -->
  <script src="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.js"></script>
  
  <script>
    let map;
    let userMarker;
    let markers = [];
    let currentUserLocation = null;
    let routingControl = null;
    let destinationMarker = null;

    // Museum data - loaded from database
    let museumMarkers = [];

    // Load user info on page load
    async function loadUserInfo() {
      try {
        const response = await fetch('profile/getUserInfo.php');
        if (response.ok) {
          const data = await response.json();
          
          if (data.loggedIn) {
            showUserLoggedInState(data);
          } else {
            showUserNotLoggedInState();
          }
        } else {
          showUserNotLoggedInState();
        }
      } catch (error) {
        console.error('Error loading user info:', error);
        showUserNotLoggedInState();
      }
    }

    function showUserLoggedInState(userData) {
      const loggedInDiv = document.getElementById('userLoggedIn');
      const notLoggedInDiv = document.getElementById('usernotLoggedIn');
      
      // Show logged in state, hide not logged in state
      loggedInDiv.style.display = 'flex';
      notLoggedInDiv.style.display = 'none';
      
      // Update user avatar
      const avatarElement = document.getElementById('userAvatar');
      avatarElement.src = userData.avatarRelative || 'avatar/default.png';
      
      // Update user name
      const nameElement = document.getElementById('userName');
      nameElement.textContent = userData.username || 'Guest User';
      
      // Apply role-based styling
      // First, remove any existing role classes
      nameElement.classList.remove('admin', 'customerpre', 'customer');
      avatarElement.classList.remove('admin', 'customerpre', 'customer');
      
      // Add appropriate class based on role
      const role = userData.role ? userData.role.toLowerCase() : 'customer';
      nameElement.classList.add(role);
      avatarElement.classList.add(role);
      
      // Update user points
      const pointsElement = document.getElementById('userPoints');
      pointsElement.textContent = (userData.score || 0);
    }

    function showUserNotLoggedInState() {
      const loggedInDiv = document.getElementById('userLoggedIn');
      const notLoggedInDiv = document.getElementById('usernotLoggedIn');
      
      // Show not logged in state, hide logged in state
      loggedInDiv.style.display = 'none';
      notLoggedInDiv.style.display = 'flex';
    }

    function goToLogin() {
      // Redirect to login page
      window.location.href = 'login.php?token=1';
    }

    function navigateToPage(page) {
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
      });
      
      event.target.closest('.nav-item').classList.add('active');
      
      switch(page) {
        case 'home':
          window.location.href = '/index.php';
          break;
        case 'map':
          // Already on map page
          break;
        case 'checkin':
          window.location.href = '/checkin/checkin.html';
          break;
        case 'leaderboard':
          window.location.href = '/leaderboard/leaderboard.html';
          break;
        case 'profile':
          window.location.href = '/profile/profile.html';
          break;
      }
    }

    // Map functions
    function initMap() {
      // Initialize map with default location (Hanoi)
      map = L.map('mapContainer').setView([21.0285, 105.8542], 13);

      // Add OpenStreetMap tiles
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors'
      }).addTo(map);

      // Get user location and center map
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          position => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            currentUserLocation = [lat, lng];
            
            // Center map on user location
            map.setView([lat, lng], 15);
            
            // Add user marker
            if (userMarker) {
              map.removeLayer(userMarker);
            }
            
            userMarker = L.marker([lat, lng], {
              icon: L.divIcon({
                className: 'user-marker',
                html: '<div style="background: #007bff; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">üìç</div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
              })
            }).addTo(map);
            
            userMarker.bindPopup('<b>V·ªã tr√≠ c·ªßa b·∫°n</b>').openPopup();
            
            // Update address
            reverseGeocode(lat, lng).then(address => {
              if (address) {
                userMarker.setPopupContent(`<b>V·ªã tr√≠ c·ªßa b·∫°n</b><br>${address}`);
              }
            });
          },
          error => {
            console.warn('Geolocation error:', error);
            alert('Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i. S·ª≠ d·ª•ng v·ªã tr√≠ m·∫∑c ƒë·ªãnh.');
          }
        );
      }

      // Load existing markers
      loadMarkers();
    }

    async function loadMarkers() {
      // Clear existing markers
      markers.forEach(marker => map.removeLayer(marker.leafletMarker));
      markers = [];

      try {
        // Fetch museums from database using existing API
        const response = await fetch('getMuseums.php');
        if (!response.ok) {
          throw new Error('Failed to fetch museums');
        }
        
        const museums = await response.json();
        
        // Convert getMuseums.php format to map format
        museumMarkers = museums.map(museum => ({
          id: museum.MuseumID,
          name: museum.MuseumName,
          lat: parseFloat(museum.Latitude),
          lng: parseFloat(museum.Longitude),
          type: 'museum',
          description: museum.Description || 'B·∫£o t√†ng vƒÉn h√≥a l·ªãch s·ª≠',
          address: museum.Address || 'ƒêang c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ...'
        }));
        
        // Add markers to map
        museumMarkers.forEach(markerData => {
          addMarkerToMap(markerData);
        });
        
        console.log(`Loaded ${museumMarkers.length} museums from database`);
      } catch (error) {
        console.error('Error loading markers:', error);
        alert('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu b·∫£o t√†ng. Vui l√≤ng th·ª≠ l·∫°i sau.');
      }
    }

    function addMarkerToMap(markerData) {
      const iconHtml = getMarkerIcon(markerData.type);
      
      const marker = L.marker([markerData.lat, markerData.lng], {
        icon: L.divIcon({
          className: 'custom-marker',
          html: iconHtml,
          iconSize: [30, 30],
          iconAnchor: [15, 30],
          popupAnchor: [0, -30]
        })
      }).addTo(map);

      const popupContent = `
        <div class="marker-popup">
          <h4>${markerData.name}</h4>
          <p><strong>Lo·∫°i:</strong> ${getTypeLabel(markerData.type)}</p>
          <p><strong>M√¥ t·∫£:</strong> ${markerData.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}</p>
          <p><strong>ƒê·ªãa ch·ªâ:</strong> ${markerData.address || 'ƒêang c·∫≠p nh·∫≠t...'}</p>
        </div>
      `;

      marker.bindPopup(popupContent);

      // Store marker data
      markers.push({
        id: markerData.id,
        data: markerData,
        leafletMarker: marker
      });
    }

    function getMarkerIcon(type) {
      const icons = {
        museum: 'üèõÔ∏è',
        historical: 'üèõÔ∏è',
        cultural: 'üé≠',
        tourist: 'üìç',
        other: 'üìå'
      };
      
      const icon = icons[type] || 'üìå';
      return `<div style="background: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid #333; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${icon}</div>`;
    }

    function getTypeLabel(type) {
      const labels = {
        museum: 'B·∫£o t√†ng',
        historical: 'Di t√≠ch l·ªãch s·ª≠',
        cultural: 'VƒÉn h√≥a',
        tourist: 'Du l·ªãch',
        other: 'Kh√°c'
      };
      return labels[type] || 'Kh√°c';
    }


    function locateUser() {
      if (currentUserLocation) {
        map.setView(currentUserLocation, 16);
        if (userMarker) {
          userMarker.openPopup();
        }
      } else {
        alert('V·ªã tr√≠ ch∆∞a ƒë∆∞·ª£c x√°c ƒë·ªãnh');
      }
    }

    // Cancel route and clear directions
    function cancelRoute() {
      // Remove routing control if exists
      if (routingControl) {
        map.removeControl(routingControl);
        routingControl = null;
      }
      
      // Remove destination marker if exists
      if (destinationMarker) {
        map.removeLayer(destinationMarker);
        destinationMarker = null;
      }
      
      // Hide cancel route button and reset routing toggle button
      document.getElementById('cancelRouteBtn').style.display = 'none';
      document.getElementById('routingToggleBtn').innerHTML = 'üìã H∆∞·ªõng d·∫´n';
      document.getElementById('routingToggleBtn').title = '·∫®n/hi·ªán h∆∞·ªõng d·∫´n';
      
      // Optionally return to user location
      if (currentUserLocation) {
        map.setView(currentUserLocation, 14);
      }
    }

    // Toggle routing panel visibility
    function toggleRoutingPanel() {
      if (routingControl) {
        const routingContainer = document.querySelector('.leaflet-routing-container');
        if (routingContainer) {
          const isHidden = routingContainer.style.display === 'none';
          routingContainer.style.display = isHidden ? 'block' : 'none';
          
          // Update button text
          const toggleBtn = document.getElementById('routingToggleBtn');
          if (isHidden) {
            toggleBtn.innerHTML = 'üìã H∆∞·ªõng d·∫´n';
            toggleBtn.title = '·∫®n h∆∞·ªõng d·∫´n';
          } else {
            toggleBtn.innerHTML = 'üìã Hi·ªán h∆∞·ªõng d·∫´n';
            toggleBtn.title = 'Hi·ªán h∆∞·ªõng d·∫´n';
          }
        }
      } else {
        // No routing active - show message
        alert('Ch∆∞a c√≥ ch·ªâ ƒë∆∞·ªùng n√†o ƒë∆∞·ª£c t·∫°o. H√£y ch·ªçn "Ch·ªâ ƒë∆∞·ªùng" t·ª´ m·ªôt b·∫£o t√†ng ƒë·ªÉ b·∫Øt ƒë·∫ßu.');
      }
    }

    async function reverseGeocode(lat, lng) {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&accept-language=vi`);
        const data = await response.json();
        return data.display_name || '';
      } catch (error) {
        console.error('Reverse geocoding error:', error);
        return '';
      }
    }

    function toggleMarkerList() {
      // Create a list of all markers
      let listHtml = '<h4>Danh s√°ch ƒëi·ªÉm ƒë√°nh d·∫•u:</h4>';
      markers.forEach(marker => {
        listHtml += `
          <div style="margin: 8px 0; padding: 8px; background: #f9f9f9; border-radius: 4px; cursor: pointer;" onclick="map.setView([${marker.data.lat}, ${marker.data.lng}], 16); markers.find(m => m.id === ${marker.id}).leafletMarker.openPopup();">
            <strong>${marker.data.name}</strong><br>
            <small>${getTypeLabel(marker.data.type)}</small>
          </div>
        `;
      });
      
      // Show in a popup
      const popup = L.popup()
        .setLatLng(map.getCenter())
        .setContent(listHtml)
        .openOn(map);
    }


    // Parse URL parameters
    function getUrlParams() {
      const params = new URLSearchParams(window.location.search);
      return {
        highlight: params.get('highlight'),
        name: params.get('name'),
        lat: params.get('lat'),
        lng: params.get('lng'),
        route: params.get('route') === 'true'
      };
    }

    // Handle directions from index.php
    function handleDirectionsRequest(params) {
      if (params.route && params.lat && params.lng && currentUserLocation) {
        const destination = [parseFloat(params.lat), parseFloat(params.lng)];
        
        // Clear existing route if any
        cancelRoute();
        
        // Highlight destination marker
        destinationMarker = L.marker(destination, {
          icon: L.divIcon({
            className: 'highlight-marker',
            html: '<div style="background: #ff4444; color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 24px; border: 3px solid white; box-shadow: 0 3px 6px rgba(0,0,0,0.4);">üèõÔ∏è</div>',
            iconSize: [40, 40],
            iconAnchor: [20, 40]
          })
        }).addTo(map);

        destinationMarker.bindPopup(`<b>${params.name}</b><br>ƒê√≠ch ƒë·∫øn c·ªßa b·∫°n`).openPopup();

        // Try to create route if routing library is available
        if (typeof L.Routing !== 'undefined') {
          try {
            routingControl = L.Routing.control({
              waypoints: [
                L.latLng(currentUserLocation[0], currentUserLocation[1]),
                L.latLng(destination[0], destination[1])
              ],
              routeWhileDragging: false,
              addWaypoints: false,
              createMarker: function() { return null; }, // Hide default markers
              lineOptions: {
                styles: [{ color: '#007bff', weight: 6, opacity: 0.8 }]
              }
            }).addTo(map);
            
            // Hide routing panel by default and add close button
            setTimeout(() => {
              const routingContainer = document.querySelector('.leaflet-routing-container');
              if (routingContainer) {
                routingContainer.style.display = 'none';
                
                // Add custom close button if not already exists
                if (!routingContainer.querySelector('.custom-close-btn')) {
                  const closeBtn = document.createElement('button');
                  closeBtn.className = 'custom-close-btn';
                  closeBtn.innerHTML = '‚úï';
                  closeBtn.title = 'ƒê√≥ng h∆∞·ªõng d·∫´n';
                  closeBtn.onclick = function() {
                    routingContainer.style.display = 'none';
                    // Update toggle button text
                    document.getElementById('routingToggleBtn').innerHTML = 'üìã Hi·ªán h∆∞·ªõng d·∫´n';
                    document.getElementById('routingToggleBtn').title = 'Hi·ªán h∆∞·ªõng d·∫´n';
                  };
                  
                  // Insert close button at the top of routing container
                  routingContainer.insertBefore(closeBtn, routingContainer.firstChild);
                }
              }
            }, 100);
            
            // Show cancel route button and update routing toggle button
            document.getElementById('cancelRouteBtn').style.display = 'block';
            document.getElementById('routingToggleBtn').innerHTML = 'üìã Hi·ªán h∆∞·ªõng d·∫´n';
            document.getElementById('routingToggleBtn').title = 'Hi·ªán h∆∞·ªõng d·∫´n';
          } catch (error) {
            console.warn('Routing not available:', error);
          }
        }
        
        // Center map to show route
        setTimeout(() => {
          map.fitBounds([currentUserLocation, destination], { padding: [20, 20] });
        }, 1000);
      }
    }

    // Initialize map when page loads
    document.addEventListener('DOMContentLoaded', function() {
      loadUserInfo();
      initMap();
      
      // Handle URL parameters after map is initialized
      setTimeout(() => {
        const params = getUrlParams();
        if (params.highlight || params.route) {
          handleDirectionsRequest(params);
        }
      }, 2000); // Wait for geolocation to complete
    });
  </script>
</body>
</html>